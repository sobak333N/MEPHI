
#include<stdlib.h>

 

#include<conio.h>

 

#include<string.h>

 

struct Stack {

 

char c;

 

Stack *Next;

 

} ;

 

int Prior (char);

 

void main () {

 

Stack *t;

 

char a, In[50], Out[50];

// Входная и выходная строки

Stack *Op = NULL;

// Стек операций Op – пуст

int k, l;

// Текущие индексы для строк

puts(" Input formula : ");

 

gets(In);

 

k=l=0;

 

while ( In[k] != '\0') {

 

//================= Часть 1 ==============================

if ( In[k] == ')' ) {

// Если очередной символ ")", выталкиваем из

 

// стека все знаки операций в выходную строку

while ( (Op -> c) != '(' ) {

// до первой открывающей скобки "("

t = Op;

// Заносим в него вершину стека

a = t -> c;

// B а записываем значение элемента вершины

Op = t -> Next;

// В вершину заносим адресную часть

delete t;

// Сняли указатель с элемента (извлекли)

if ( !(Op) ) a = '\0';

 

 

 

Out[l++] = a;

// Информационную часть – в выходную строку

}

 

 

 

t = Op;

 

// Удаляем из стека открывающуюся скобку

Op = t -> Next;

 

 

if ( Op = = NULL ) {

// Стек пустой

puts (" End of Stack!");

 

break;

 

 

 

}

 

 

 

delete t;

}

//====================== Часть 2 =========================

if ( (In[k] >= 'a') && (In[k] <= 'z'))

// Если символ буква,

Out[l++] = In[k];

// то заносим ее в выходную строку

//====================== Часть 3 =========================

if ( In[k] == '(' ) {

// Если символ входной строки открывающаяся

t = new Stack;

// скобка, то заталкиваем ее в стек

 

 

t -> c = In[k];

 

 

t -> Next = Op;

 

 

141

Op = t;

}

//======================== Часть 4 ========================

if ( In[k] == '+' || In[k] == '–' || In[k] == '*' || In[k] == '/') {

//Если знак операции, то переписываем в выходную строку все операции, while ( (Op !=NULL) && (Prior (Op -> c) >= Prior (In[k]))) {

//находящиеся в стеке с большим или равным приоритетом

t = Op;

a = t -> c;

Op = t -> Next;

delete t; // Извлекли элемент из стека

// if ( !(Op) ) a = '\0'; Out[l++] = a;

 

}

 

 

t = new Stack;

// Записываем в стек поступившую информацию

 

t -> c = In[k];

 

 

t -> Next = Op;

 

}

Op = t;

 

k++;

 

 

 

}

// Конец цикла анализа входной строки

//======================== Часть 5 =======================

while ( Op !=NULL) { // После рассмотрения всей входной информации

t = Op;

// переписываем операции из стека

a = t -> c;

// в выходную строку

Op = t -> Next; delete t; Out[l++] = a;

}

Out[l] = '\0';

printf("\n Polish = %s", Out); // Печатаем полученную строку getch();

}

//========= Функция реализации приоритета операций ============

int Prior ( char a ) { switch ( a ) {

case '*': case '/': return 3; case '–': case '+': return 2; case '(': return 1;

}

return 0;

}